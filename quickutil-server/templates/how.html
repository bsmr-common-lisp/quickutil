{namespace quickutil-server.view}

{template renderHow}
  {call wrapper}
    {param title: 'How to use it | Quickutil' /}
    {param current: 'how' /}
    {param categories: $categories /}
    {param javascripts: $staticFiles.javascripts /}
    {param css: $staticFiles.css /}
    {param isPjax: $isPjax /}
    {param body}
      <h2>How to use <span class="logo">Quickutil</span></h2>

      <ul class="toc">
        <li><a href="#utils-categories-syms">Utilities, Categories, and Symbols</a></li>
        <li><a href="#loading-quickutil">Loading <span class="logo">Quickutil</span></a></li>
        <li><a href="#generating">Generating a Utility File</a></li>
        <li><a href="#interactive">Interactive Development</a></li>
        <li><a href="#autoloading">Autoloading Utilities</a></li>
        <!-- <li><a href="#provides">Finding the Right Utility to Load</a></li> -->
      </ul>

      <a id="utils-categories-syms"></a>
      <h3>Utilities, Categories, and Symbols</h3>

      <p><span class="logo">Quickutil</span> is centered around the idea of a <strong>utility</strong>, a self-contained piece of functionality or very related functionalities that typically solve a small, generic problem. Utilities are assigned a variety of <strong>categories</strong>, such as <code>math</code> or <code>sequences</code>. Categories can also act as <em>micro-libraries</em>, such as <code>split-sequence</code>. Finally, utilities provide <strong>symbols</strong>, which might be functions, macros, constants, etc.</p>

      <p>While it is most often the case, it is not necessarily true that a utility corresponds to a single symbol. For example, the utility <code>:exponential-e</code> actually provides two symbols: <code>exponential-e</code> and <code>ee</code>.</p>

      <p><span class="logo">Quickutil</span> allows one to query for functionality based on the three above granularities, all at the same time. It queries efficiently, too. So if you want the symbol <code>ee</code> specifically, as well as everything in the <code>math</code> category, it will still only load the utility containing <code>ee</code> once.</p>

      <a id="loading-quickutil"></a>
      <h3>Loading <span class="logo">Quickutil</span></h3>

      <p>Currently, <span class="logo">Quickutil</span> is in beta, and not a part of Quicklisp. The latest <span class="logo">Quickutil</span> tarball can be downloaded into a place Quicklisp can see it, and it can be loaded via:</p>

      <pre class="example-code">
        <code>(ql:quickload :quickutil)</code>
      </pre>

      <p>Loading this will create two packages: <code>quickutil-client</code> or <code>qtlc</code> for all of the downloading and management functions, and <code>quickutil</code> or <code>qtl</code> for all of the installed utilities.</p>

      <a id="generating"></a>
      <h3>Generating a Utility File</h3>

      <p>Almost every project has a <code>utils.lisp</code> file or section, and <span class="logo">Quickutil</span> aims to manage that by generating it automatically based off of what you need.</p>

      <p>Generating the utilities file is done with <code>qtlc:save-utils-as</code>, which takes the utilities, categories, and symbols that you want to save.</p>

      <pre class="example-code">
        <code>(qtlc:save-utils-as "utils.lisp"</code></br>
        <code>&nbsp;&nbsp;:utilities '(:iota :riffle)</code><br/>
        <code>&nbsp;&nbsp;:categories '(:alexandria)</code><br>
        <code>&nbsp;&nbsp;:symbols '(:split-sequence-if-not)</code>
      </pre>

      <p>Now, the file <code>utils.lisp</code> will be saved to disk and can be added to your project. <strong>This file does <em>not</em> depend on <span class="logo">Quickutil</span> or have any network dependencies!</strong> It is a completely self-contained, readable, and modifiable source file. (However, we don't recommend modifying it so it can be regenerated in the future.)</p>

      <p>To use it, simply add it as a dependency to your ASD file, or load it into the REPL. All of the utilities that you saved will be in the package <code>quickutil</code> or <code>qtl</code>.</p>

      <a id="interactive"></a>
      <h3>Interactive Development</h3>

      <p>Sometimes when interactively developing your program, you do not want to keep generating a new utility file every time you need a new function. <span class="logo">Quickutil</span> includes a function <code>qtlc:utilize</code> which is very similar to <code>save-utils-as</code> and allows one to directly download and install the utilities right into the running image.</p>

      <pre class="example-code">
        <code>(qtlc:utilize</code></br>
        <code>&nbsp;&nbsp;:utilities '(:iota :riffle)</code><br/>
        <code>&nbsp;&nbsp;:categories '(:alexandria)</code><br>
        <code>&nbsp;&nbsp;:symbols '(:split-sequence-if-not)</code>
      </pre>

      <p>This has the same effect as downloading the utilities to a file as if by <code>save-utils-as</code> and compiling/loading it right away.</p>
      
      <p>For convenience, there are three functions with a subset of functionality for special cases:</p>
      <ul>
        <li><code>(qtlc:utilize-utilities :riffle :weave)</code>: download and install the utilities <code>:riffle</code> and <code>:weave</code>.</li>
        <li><code>(qtlc:utilize-categories :math :alexandria)</code>: download and install everything in the categories <code>math</code> and <code>alexandria</code>.</li>
        <li><code>(qtlc:utilize-symbols :split-sequence-if-not)</code>: download and install the utility containing the function <code>split-sequence-if-not</code>.</li>
      </ul>
      
      <a id="autoloading"></a>
      <h3>Autoloading Utilities</h3>
      <p>Especially for quick REPL interactions, it is nice to be able to use utilities without explicitly loading them simply because it is faster and requires less typing. <span class="logo">Quickutil</span> provides an optional <em>autoload syntax</em>, <code>#?</code>, which autoloads the symbol right after it. The syntax is disabled by default, and can be enabled with <code>qtlc:enable-autoload-syntax</code>. For example:</p>

      <pre class="example-code">
        <code>&gt; (qtlc:enable-autoload-syntax)</code><br/>
        <code>&gt; (#?implode (#?shuffle (#?explode "hello")))</code><br/>
        <code>"lolhe"</code>
      </pre>

      <p>Autoloading only uses the network when it needs to; already-loaded symbols are recycled.</p>
      
      <p>You can permanently enable autoload syntax by loading <span class="logo">Quickutil</span> and putting the <code>qtlc:enable-autoload-syntax</code> call in your Lisp's initialization file.</p>
<!--      
      <a id="provides"></a>
      <h3>Finding the Right Utility to Load</h3>
      <p>If you know which function, macro, etc. that you want, but you neither know nor remember which utility it originates from, you can use <code>qtlc:who-provides</code>.</p>

      <pre class="example-code">
        <code>&gt; (qtlc:who-provides :ee)</code><br/>
        <code>:EXPONENTIAL-E</code><br/>
        <code>&gt; (qtlc:who-provides :split-sequence-if-not)</code><br/>
        <code>:SPLIT-SEQUENCE</code>
      </pre>

      <p>If you would like to directly download utilities based off of provided symbols instead of utility names, you can use <code>qtlc:utilize-symbols</code>.</p>

      <pre class="example-code">
        <code>&gt; (qtlc:utilize-symbols :ee :riffle)</code><br/>
        <code>&gt; (qtl:riffle '(1 2 3) qtl:ee)</code><br/>
        <code>(1 2.718281828459045d0 2 2.718281828459045d0 3)</code>
      </pre>
      
      <div class="footer-next-link">
        <a href="/list" class="lsf-icon" data-pjax="#main">Discover utilities</a>
      </div>
-->  
    {/param}
  {/call}
{/template}
